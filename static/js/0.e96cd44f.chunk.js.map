{"version":3,"sources":["../node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","isLikeNone","x","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayU8FromWasm0","passArray8ToWasm0","_assertClass","instance","klass","Error","name","cachegetUint32Memory0","getUint32Memory0","Uint32Array","getArrayU32FromWasm0","encrypt_with_password","password","salt","nonce","data","retptr","ptr0","len0","ptr1","len1","ptr2","len2","ptr3","len3","r0","r1","decrypt_with_password","min_fee","tx","linear_fee","Transaction","LinearFee","BigNum","__wrap","make_daedalus_bootstrap_witness","tx_body_hash","addr","key","TransactionHash","ByronAddress","LegacyDaedalusPrivateKey","BootstrapWitness","make_icarus_bootstrap_witness","Bip32PrivateKey","make_vkey_witness","sk","PrivateKey","Vkeywitness","hash_auxiliary_data","auxiliary_data","AuxiliaryData","AuxiliaryDataHash","hash_transaction","tx_body","TransactionBody","get_implicit_input","txbody","pool_deposit","key_deposit","Value","get_deposit","min_ada_required","assets","minimum_utxo_val","encode_arbitrary_bytes_as_metadatum","bytes","TransactionMetadatum","decode_arbitrary_bytes_from_metadatum","metadata","v0","encode_json_str_to_metadatum","json","schema","decode_metadatum_to_json_str","metadatum","CertificateKind","Object","freeze","StakeRegistration","StakeDeregistration","StakeDelegation","PoolRegistration","PoolRetirement","GenesisKeyDelegation","MoveInstantaneousRewardsCert","MIRPot","Reserves","Treasury","MIRKind","ToOtherPot","ToStakeCredentials","RelayKind","SingleHostAddr","SingleHostName","MultiHostName","NativeScriptKind","ScriptPubkey","ScriptAll","ScriptAny","ScriptNOfK","TimelockStart","TimelockExpiry","ScriptHashNamespace","NativeScript","NetworkIdKind","Testnet","Mainnet","LanguageKind","PlutusV1","PlutusDataKind","ConstrPlutusData","Map","List","Integer","Bytes","RedeemerTagKind","Spend","Mint","Cert","Reward","TransactionMetadatumKind","MetadataMap","MetadataList","Int","Text","MetadataJsonSchema","NoConversions","BasicConversions","DetailedSchema","Address","this","__destroy_into_raw","prefix","create","prototype","bech_str","AssetName","AssetNames","index","elem","Assets","value","GeneralTransactionMetadata","NativeScripts","native_scripts","PlutusScripts","plutus_scripts","AuxiliaryDataSet","tx_index","BaseAddress","StakeCredential","network","payment","stake","BigInt","text","other","rhs_value","string","Bip32PublicKey","bech32_str","entropy","PublicKey","Block","Header","TransactionBodies","TransactionWitnessSets","header","transaction_bodies","transaction_witness_sets","auxiliary_data_set","invalid_transactions","passArray32ToWasm0","BlockHash","Vkey","Ed25519Signature","vkey","signature","chain_code","attributes","BootstrapWitnesses","s","protocol_magic","Certificate","stake_registration","stake_deregistration","stake_delegation","pool_registration","pool_retirement","genesis_key_delegation","move_instantaneous_rewards_cert","Certificates","PlutusList","tag","CostModel","operation","cost","Costmdls","Language","Languages","DNSRecordAorAAAA","dns_name","DNSRecordSRV","DataHash","Ed25519KeyHash","Ed25519KeyHashes","input","EnterpriseAddress","ExUnitPrices","UnitInterval","mem_price","step_price","ExUnits","steps","TransactionMetadatumLabels","GenesisDelegateHash","GenesisHash","GenesisHashes","VRFKeyHash","genesishash","genesis_delegate_hash","vrf_keyhash","HeaderBody","KESSignature","header_body","body_signature","VRFVKey","VRFCert","OperationalCert","ProtocolVersion","block_number","slot","prev_hash","issuer_vkey","vrf_vkey","nonce_vrf","leader_vrf","block_body_size","block_body_hash","operational_cert","protocol_version","Ipv4","Ipv6","KESVKey","coefficient","constant","MIRToStakeCredentials","cred","delta","StakeCredentials","ScriptHash","MintAssets","ScriptHashes","MoveInstantaneousReward","pot","amount","amounts","move_instantaneous_reward","MultiAsset","rhs_ma","namespace","script_pubkey","script_all","script_any","script_n_of_k","timelock_start","timelock_expiry","NetworkId","NetworkInfo","network_id","Nonce","hash","hot_vkey","sequence_number","kes_period","sigma","PlutusData","PlutusMap","constr_plutus_data","map","list","integer","PlutusScript","Pointer","cert_index","PointerAddress","PoolMetadata","URL","PoolMetadataHash","url","pool_metadata_hash","PoolParams","RewardAddress","Relays","operator","pledge","margin","reward_account","pool_owners","relays","pool_metadata","pool_params","pool_keyhash","epoch","message","ProposedProtocolParameterUpdates","ProtocolParamUpdate","minfee_a","minfee_b","max_block_body_size","max_tx_size","max_block_header_size","max_epoch","n_opt","pool_pledge_influence","expansion_rate","treasury_growth_rate","d","extra_entropy","ProtocolVersions","min_pool_cost","ada_per_utxo_byte","cost_models","execution_costs","max_tx_ex_units","max_block_ex_units","max_value_size","major","minor","PublicKeys","Redeemer","RedeemerTag","ex_units","Redeemers","Relay","single_host_addr","single_host_name","multi_host_name","RewardAddresses","ScriptDataHash","n","addr_keyhash","port","ipv4","ipv6","stake_credential","Strings","TransactionWitnessSet","body","witness_set","TransactionInputs","TransactionOutputs","certs","withdrawals","Withdrawals","update","Update","auxiliary_data_hash","validity_start_interval","mint","script_data_hash","collateral","required_signers","inputs","outputs","fee","ttl","TransactionBuilder","TransactionInput","address","output","TransactionOutput","transaction_id","int","data_hash","TransactionUnspentOutput","vkeys","Vkeywitnesses","bootstraps","plutus_data","redeemers","numerator","denominator","proposed_protocol_parameter_updates","proof","coin","multiasset","rhs","pk","Vkeys","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","__wbg_new_3a746f2619705add","Function","__wbg_call_f54d3a6dadb199ca","call","__wbindgen_jsval_eq","__wbg_self_ac379e780a0d8b94","self","__wbg_require_6461b1e9a0d7c34a","__wbg_crypto_1e4302b85d4f64a2","crypto","__wbindgen_is_undefined","__wbg_getRandomValues_1b4ba144162a5c9e","getRandomValues","__wbg_getRandomValues_1ef11e888e5228e9","arg2","__wbg_randomFillSync_1b52c8482374c55b","randomFillSync","__wbindgen_string_get","__wbindgen_debug_string","debugString","val","type","description","isArray","debug","i","className","builtInMatches","exec","toString","JSON","stringify","_","stack","__wbindgen_throw","__wbindgen_rethrow","exports","originalModule","webpackPolyfill","children","defineProperty","enumerable","get","l"],"mappings":"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","file":"static/js/0.e96cd44f.chunk.js","sourcesContent":["import * as wasm from './cardano_serialization_lib_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {string} password\n* @param {string} salt\n* @param {string} nonce\n* @param {string} data\n* @returns {string}\n*/\nexport function encrypt_with_password(password, salt, nonce, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} data\n* @returns {string}\n*/\nexport function decrypt_with_password(password, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.decrypt_with_password(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {Transaction} tx\n* @param {LinearFee} linear_fee\n* @returns {BigNum}\n*/\nexport function min_fee(tx, linear_fee) {\n    _assertClass(tx, Transaction);\n    _assertClass(linear_fee, LinearFee);\n    var ret = wasm.min_fee(tx.ptr, linear_fee.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {LegacyDaedalusPrivateKey} key\n* @returns {BootstrapWitness}\n*/\nexport function make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, LegacyDaedalusPrivateKey);\n    var ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {Bip32PrivateKey} key\n* @returns {BootstrapWitness}\n*/\nexport function make_icarus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, Bip32PrivateKey);\n    var ret = wasm.make_icarus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {PrivateKey} sk\n* @returns {Vkeywitness}\n*/\nexport function make_vkey_witness(tx_body_hash, sk) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(sk, PrivateKey);\n    var ret = wasm.make_vkey_witness(tx_body_hash.ptr, sk.ptr);\n    return Vkeywitness.__wrap(ret);\n}\n\n/**\n* @param {AuxiliaryData} auxiliary_data\n* @returns {AuxiliaryDataHash}\n*/\nexport function hash_auxiliary_data(auxiliary_data) {\n    _assertClass(auxiliary_data, AuxiliaryData);\n    var ret = wasm.hash_auxiliary_data(auxiliary_data.ptr);\n    return AuxiliaryDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} tx_body\n* @returns {TransactionHash}\n*/\nexport function hash_transaction(tx_body) {\n    _assertClass(tx_body, TransactionBody);\n    var ret = wasm.hash_transaction(tx_body.ptr);\n    return TransactionHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {Value}\n*/\nexport function get_implicit_input(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = wasm.get_implicit_input(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return Value.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {BigNum}\n*/\nexport function get_deposit(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = wasm.get_deposit(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {Value} assets\n* @param {BigNum} minimum_utxo_val\n* @returns {BigNum}\n*/\nexport function min_ada_required(assets, minimum_utxo_val) {\n    _assertClass(assets, Value);\n    _assertClass(minimum_utxo_val, BigNum);\n    var ret = wasm.min_ada_required(assets.ptr, minimum_utxo_val.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {Uint8Array} bytes\n* @returns {TransactionMetadatum}\n*/\nexport function encode_arbitrary_bytes_as_metadatum(bytes) {\n    var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadata\n* @returns {Uint8Array}\n*/\nexport function decode_arbitrary_bytes_from_metadatum(metadata) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadata, TransactionMetadatum);\n        wasm.decode_arbitrary_bytes_from_metadatum(retptr, metadata.ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v0 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {TransactionMetadatum}\n*/\nexport function encode_json_str_to_metadatum(json, schema) {\n    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_json_str_to_metadatum(ptr0, len0, schema);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadatum\n* @param {number} schema\n* @returns {string}\n*/\nexport function decode_metadatum_to_json_str(metadatum, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadatum, TransactionMetadatum);\n        wasm.decode_metadatum_to_json_str(retptr, metadatum.ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n*/\nexport const CertificateKind = Object.freeze({ StakeRegistration:0,\"0\":\"StakeRegistration\",StakeDeregistration:1,\"1\":\"StakeDeregistration\",StakeDelegation:2,\"2\":\"StakeDelegation\",PoolRegistration:3,\"3\":\"PoolRegistration\",PoolRetirement:4,\"4\":\"PoolRetirement\",GenesisKeyDelegation:5,\"5\":\"GenesisKeyDelegation\",MoveInstantaneousRewardsCert:6,\"6\":\"MoveInstantaneousRewardsCert\", });\n/**\n*/\nexport const MIRPot = Object.freeze({ Reserves:0,\"0\":\"Reserves\",Treasury:1,\"1\":\"Treasury\", });\n/**\n*/\nexport const MIRKind = Object.freeze({ ToOtherPot:0,\"0\":\"ToOtherPot\",ToStakeCredentials:1,\"1\":\"ToStakeCredentials\", });\n/**\n*/\nexport const RelayKind = Object.freeze({ SingleHostAddr:0,\"0\":\"SingleHostAddr\",SingleHostName:1,\"1\":\"SingleHostName\",MultiHostName:2,\"2\":\"MultiHostName\", });\n/**\n*/\nexport const NativeScriptKind = Object.freeze({ ScriptPubkey:0,\"0\":\"ScriptPubkey\",ScriptAll:1,\"1\":\"ScriptAll\",ScriptAny:2,\"2\":\"ScriptAny\",ScriptNOfK:3,\"3\":\"ScriptNOfK\",TimelockStart:4,\"4\":\"TimelockStart\",TimelockExpiry:5,\"5\":\"TimelockExpiry\", });\n/**\n* Each new language uses a different namespace for hashing its script\n* This is because you could have a language where the same bytes have different semantics\n* So this avoids scripts in different languages mapping to the same hash\n* Note that the enum value here is different than the enum value for deciding the cost model of a script\n*/\nexport const ScriptHashNamespace = Object.freeze({ NativeScript:0,\"0\":\"NativeScript\", });\n/**\n*/\nexport const NetworkIdKind = Object.freeze({ Testnet:0,\"0\":\"Testnet\",Mainnet:1,\"1\":\"Mainnet\", });\n/**\n*/\nexport const LanguageKind = Object.freeze({ PlutusV1:0,\"0\":\"PlutusV1\", });\n/**\n*/\nexport const PlutusDataKind = Object.freeze({ ConstrPlutusData:0,\"0\":\"ConstrPlutusData\",Map:1,\"1\":\"Map\",List:2,\"2\":\"List\",Integer:3,\"3\":\"Integer\",Bytes:4,\"4\":\"Bytes\", });\n/**\n*/\nexport const RedeemerTagKind = Object.freeze({ Spend:0,\"0\":\"Spend\",Mint:1,\"1\":\"Mint\",Cert:2,\"2\":\"Cert\",Reward:3,\"3\":\"Reward\", });\n/**\n*/\nexport const TransactionMetadatumKind = Object.freeze({ MetadataMap:0,\"0\":\"MetadataMap\",MetadataList:1,\"1\":\"MetadataList\",Int:2,\"2\":\"Int\",Bytes:3,\"3\":\"Bytes\",Text:4,\"4\":\"Text\", });\n/**\n*/\nexport const MetadataJsonSchema = Object.freeze({ NoConversions:0,\"0\":\"NoConversions\",BasicConversions:1,\"1\":\"BasicConversions\",DetailedSchema:2,\"2\":\"DetailedSchema\", });\n/**\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bytes(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Address}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bech32(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.address_network_id(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class AssetName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_from_bytes(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} name\n    * @returns {AssetName}\n    */\n    static new(name) {\n        var ptr0 = passArray8ToWasm0(name, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_new(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class AssetNames {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetNames.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetnames_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetNames}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetnames_from_bytes(ptr0, len0);\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    static new() {\n        var ret = wasm.assetnames_new();\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.assetnames_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {AssetName}\n    */\n    get(index) {\n        var ret = wasm.assetnames_get(this.ptr, index);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} elem\n    */\n    add(elem) {\n        _assertClass(elem, AssetName);\n        wasm.assetnames_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Assets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Assets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assets_free(ptr);\n    }\n    /**\n    * @returns {Assets}\n    */\n    static new() {\n        var ret = wasm.assets_new();\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.assets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, BigNum);\n        var ret = wasm.assets_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = wasm.assets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = wasm.assets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nexport class AuxiliaryData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydata_from_bytes(ptr0, len0);\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryData}\n    */\n    static new() {\n        var ret = wasm.auxiliarydata_new();\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata | undefined}\n    */\n    metadata() {\n        var ret = wasm.auxiliarydata_metadata(this.ptr);\n        return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        wasm.auxiliarydata_set_metadata(this.ptr, metadata.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = wasm.auxiliarydata_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.auxiliarydata_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = wasm.auxiliarydata_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.auxiliarydata_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n}\n/**\n*/\nexport class AuxiliaryDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_bech32(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_bytes(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class AuxiliaryDataSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydataset_free(ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    static new() {\n        var ret = wasm.auxiliarydataset_new();\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.auxiliarydataset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} tx_index\n    * @param {AuxiliaryData} data\n    * @returns {AuxiliaryData | undefined}\n    */\n    insert(tx_index, data) {\n        _assertClass(data, AuxiliaryData);\n        var ret = wasm.auxiliarydataset_insert(this.ptr, tx_index, data.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {number} tx_index\n    * @returns {AuxiliaryData | undefined}\n    */\n    get(tx_index) {\n        var ret = wasm.auxiliarydataset_get(this.ptr, tx_index);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    indices() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydataset_indices(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class BaseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BaseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_baseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {StakeCredential} stake\n    * @returns {BaseAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, StakeCredential);\n        var ret = wasm.baseaddress_new(network, payment.ptr, stake.ptr);\n        return BaseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.baseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_cred() {\n        var ret = wasm.baseaddress_stake_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.baseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {BaseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.baseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : BaseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BigInt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigInt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bigint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigInt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_bytes(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_u64() {\n        var ret = wasm.bigint_as_u64(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {BigInt}\n    */\n    static from_str(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_str(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * returns 0 if it would otherwise underflow\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    clamped_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_clamped_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {number}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        var ret = wasm.bignum_compare(this.ptr, rhs_value.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class Bip32PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32privatekey_free(ptr);\n    }\n    /**\n    * derive this private key with the given index.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PrivateKey}\n    */\n    derive(index) {\n        var ret = wasm.bip32privatekey_derive(this.ptr, index);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * 128-byte xprv a key format in Cardano that some software still uses or requires\n    * the traditional 96-byte xprv is simply encoded as\n    * prv | chaincode\n    * however, because some software may not know how to compute a public key from a private key,\n    * the 128-byte inlines the public key in the following format\n    * prv | pub | chaincode\n    * so be careful if you see the term \"xprv\" as it could refer to either one\n    * our library does not require the pub (instead we compute the pub key when needed)\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_128_xprv(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_128_xprv(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * see from_128_xprv\n    * @returns {Uint8Array}\n    */\n    to_128_xprv() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_128_xprv(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Bip32PrivateKey}\n    */\n    static generate_ed25519_bip32() {\n        var ret = wasm.bip32privatekey_generate_ed25519_bip32();\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    to_raw_key() {\n        var ret = wasm.bip32privatekey_to_raw_key(this.ptr);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Bip32PublicKey}\n    */\n    to_public() {\n        var ret = wasm.bip32privatekey_to_public(this.ptr);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bytes(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bech32(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {Uint8Array} entropy\n    * @param {Uint8Array} password\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bip39_entropy(entropy, password) {\n        var ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Bip32PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32publickey_free(ptr);\n    }\n    /**\n    * derive this public key with the given index.\n    *\n    * # Errors\n    *\n    * If the index is not a soft derivation index (< 0x80000000) then\n    * calling this method will fail.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PublicKey}\n    */\n    derive(index) {\n        var ret = wasm.bip32publickey_derive(this.ptr, index);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_raw_key() {\n        var ret = wasm.bip32publickey_to_raw_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_bytes(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_bech32(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Block {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Block.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_block_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Block}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_from_bytes(ptr0, len0);\n        return Block.__wrap(ret);\n    }\n    /**\n    * @returns {Header}\n    */\n    header() {\n        var ret = wasm.block_header(this.ptr);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    transaction_bodies() {\n        var ret = wasm.block_transaction_bodies(this.ptr);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    transaction_witness_sets() {\n        var ret = wasm.block_transaction_witness_sets(this.ptr);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    auxiliary_data_set() {\n        var ret = wasm.block_auxiliary_data_set(this.ptr);\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    invalid_transactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_invalid_transactions(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Header} header\n    * @param {TransactionBodies} transaction_bodies\n    * @param {TransactionWitnessSets} transaction_witness_sets\n    * @param {AuxiliaryDataSet} auxiliary_data_set\n    * @param {Uint32Array} invalid_transactions\n    * @returns {Block}\n    */\n    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {\n        _assertClass(header, Header);\n        _assertClass(transaction_bodies, TransactionBodies);\n        _assertClass(transaction_witness_sets, TransactionWitnessSets);\n        _assertClass(auxiliary_data_set, AuxiliaryDataSet);\n        var ptr0 = passArray32ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_new(header.ptr, transaction_bodies.ptr, transaction_witness_sets.ptr, auxiliary_data_set.ptr, ptr0, len0);\n        return Block.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BlockHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.blockhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {BlockHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_bech32(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BlockHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_bytes(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BootstrapWitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BootstrapWitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_from_bytes(ptr0, len0);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = wasm.bootstrapwitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = wasm.bootstrapwitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @param {Uint8Array} chain_code\n    * @param {Uint8Array} attributes\n    * @returns {BootstrapWitness}\n    */\n    static new(vkey, signature, chain_code, attributes) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(attributes, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_new(vkey.ptr, signature.ptr, ptr0, len0, ptr1, len1);\n        return BootstrapWitness.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BootstrapWitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitnesses_free(ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses}\n    */\n    static new() {\n        var ret = wasm.bootstrapwitnesses_new();\n        return BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.bootstrapwitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BootstrapWitness}\n    */\n    get(index) {\n        var ret = wasm.bootstrapwitnesses_get(this.ptr, index);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, BootstrapWitness);\n        wasm.bootstrapwitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ByronAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ByronAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_byronaddress_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ByronAddress}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_from_bytes(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * returns the byron protocol magic embedded in the address, or mainnet id if none is present\n    * note: for bech32 addresses, you need to use network_id instead\n    * @returns {number}\n    */\n    byron_protocol_magic() {\n        var ret = wasm.byronaddress_byron_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.byronaddress_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {string} s\n    * @returns {ByronAddress}\n    */\n    static from_base58(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_from_base58(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {Bip32PublicKey} key\n    * @param {number} protocol_magic\n    * @returns {ByronAddress}\n    */\n    static icarus_from_key(key, protocol_magic) {\n        _assertClass(key, Bip32PublicKey);\n        var ret = wasm.byronaddress_icarus_from_key(key.ptr, protocol_magic);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {boolean}\n    */\n    static is_valid(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_is_valid(ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.byronaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {ByronAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.byronaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : ByronAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Certificate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificate_from_bytes(ptr0, len0);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeRegistration} stake_registration\n    * @returns {Certificate}\n    */\n    static new_stake_registration(stake_registration) {\n        _assertClass(stake_registration, StakeRegistration);\n        var ret = wasm.certificate_new_stake_registration(stake_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDeregistration} stake_deregistration\n    * @returns {Certificate}\n    */\n    static new_stake_deregistration(stake_deregistration) {\n        _assertClass(stake_deregistration, StakeDeregistration);\n        var ret = wasm.certificate_new_stake_deregistration(stake_deregistration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDelegation} stake_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_delegation(stake_delegation) {\n        _assertClass(stake_delegation, StakeDelegation);\n        var ret = wasm.certificate_new_stake_delegation(stake_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRegistration} pool_registration\n    * @returns {Certificate}\n    */\n    static new_pool_registration(pool_registration) {\n        _assertClass(pool_registration, PoolRegistration);\n        var ret = wasm.certificate_new_pool_registration(pool_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRetirement} pool_retirement\n    * @returns {Certificate}\n    */\n    static new_pool_retirement(pool_retirement) {\n        _assertClass(pool_retirement, PoolRetirement);\n        var ret = wasm.certificate_new_pool_retirement(pool_retirement.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisKeyDelegation} genesis_key_delegation\n    * @returns {Certificate}\n    */\n    static new_genesis_key_delegation(genesis_key_delegation) {\n        _assertClass(genesis_key_delegation, GenesisKeyDelegation);\n        var ret = wasm.certificate_new_genesis_key_delegation(genesis_key_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert\n    * @returns {Certificate}\n    */\n    static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {\n        _assertClass(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);\n        var ret = wasm.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.certificate_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {StakeRegistration | undefined}\n    */\n    as_stake_registration() {\n        var ret = wasm.certificate_as_stake_registration(this.ptr);\n        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDeregistration | undefined}\n    */\n    as_stake_deregistration() {\n        var ret = wasm.certificate_as_stake_deregistration(this.ptr);\n        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDelegation | undefined}\n    */\n    as_stake_delegation() {\n        var ret = wasm.certificate_as_stake_delegation(this.ptr);\n        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRegistration | undefined}\n    */\n    as_pool_registration() {\n        var ret = wasm.certificate_as_pool_registration(this.ptr);\n        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRetirement | undefined}\n    */\n    as_pool_retirement() {\n        var ret = wasm.certificate_as_pool_retirement(this.ptr);\n        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisKeyDelegation | undefined}\n    */\n    as_genesis_key_delegation() {\n        var ret = wasm.certificate_as_genesis_key_delegation(this.ptr);\n        return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousRewardsCert | undefined}\n    */\n    as_move_instantaneous_rewards_cert() {\n        var ret = wasm.certificate_as_move_instantaneous_rewards_cert(this.ptr);\n        return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Certificates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificates_from_bytes(ptr0, len0);\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {Certificates}\n    */\n    static new() {\n        var ret = wasm.certificates_new();\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.certificates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Certificate}\n    */\n    get(index) {\n        var ret = wasm.certificates_get(this.ptr, index);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {Certificate} elem\n    */\n    add(elem) {\n        _assertClass(elem, Certificate);\n        wasm.certificates_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ConstrPlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ConstrPlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constrplutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constrplutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ConstrPlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constrplutusdata_from_bytes(ptr0, len0);\n        return ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {Int}\n    */\n    tag() {\n        var ret = wasm.constrplutusdata_tag(this.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    data() {\n        var ret = wasm.constrplutusdata_data(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Int} tag\n    * @param {PlutusList} data\n    * @returns {ConstrPlutusData}\n    */\n    static new(tag, data) {\n        _assertClass(tag, Int);\n        var ptr0 = tag.ptr;\n        tag.ptr = 0;\n        _assertClass(data, PlutusList);\n        var ret = wasm.constrplutusdata_new(ptr0, data.ptr);\n        return ConstrPlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nexport class CostModel {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CostModel.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmodel_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CostModel}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmodel_from_bytes(ptr0, len0);\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {CostModel}\n    */\n    static new() {\n        var ret = wasm.costmodel_new();\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @param {Int} cost\n    * @returns {Int}\n    */\n    set(operation, cost) {\n        _assertClass(cost, Int);\n        var ret = wasm.costmodel_set(this.ptr, operation, cost.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @returns {Int}\n    */\n    get(operation) {\n        var ret = wasm.costmodel_get(this.ptr, operation);\n        return Int.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Costmdls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Costmdls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmdls_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Costmdls}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmdls_from_bytes(ptr0, len0);\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static new() {\n        var ret = wasm.costmdls_new();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.costmdls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Language} key\n    * @param {CostModel} value\n    * @returns {CostModel | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, Language);\n        _assertClass(value, CostModel);\n        var ret = wasm.costmdls_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @param {Language} key\n    * @returns {CostModel | undefined}\n    */\n    get(key) {\n        _assertClass(key, Language);\n        var ret = wasm.costmdls_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {Languages}\n    */\n    keys() {\n        var ret = wasm.costmdls_keys(this.ptr);\n        return Languages.__wrap(ret);\n    }\n}\n/**\n*/\nexport class DNSRecordAorAAAA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordAorAAAA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordaoraaaa_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_from_bytes(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordAorAAAA}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_new(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class DNSRecordSRV {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordSRV.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordsrv_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordSRV}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_from_bytes(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordSRV}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_new(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class DataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.datahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.datahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {DataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_bech32(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_bytes(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519KeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_bech32(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_bytes(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519KeyHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhashes_from_bytes(ptr0, len0);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    static new() {\n        var ret = wasm.ed25519keyhashes_new();\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ed25519keyhashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Ed25519KeyHash}\n    */\n    get(index) {\n        var ret = wasm.ed25519keyhashes_get(this.ptr, index);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, Ed25519KeyHash);\n        wasm.ed25519keyhashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Ed25519Signature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519Signature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519signature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Ed25519Signature}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_bech32(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {string} input\n    * @returns {Ed25519Signature}\n    */\n    static from_hex(input) {\n        var ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_hex(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519Signature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_bytes(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class EnterpriseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EnterpriseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_enterpriseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {EnterpriseAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = wasm.enterpriseaddress_new(network, payment.ptr);\n        return EnterpriseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.enterpriseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.enterpriseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {EnterpriseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.enterpriseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ExUnitPrices {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnitPrices.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunitprices_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnitPrices}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunitprices_from_bytes(ptr0, len0);\n        return ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    mem_price() {\n        var ret = wasm.exunitprices_mem_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    step_price() {\n        var ret = wasm.exunitprices_step_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} mem_price\n    * @param {UnitInterval} step_price\n    * @returns {ExUnitPrices}\n    */\n    static new(mem_price, step_price) {\n        _assertClass(mem_price, UnitInterval);\n        _assertClass(step_price, UnitInterval);\n        var ret = wasm.exunitprices_new(mem_price.ptr, step_price.ptr);\n        return ExUnitPrices.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ExUnits {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnits.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunits_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnits}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunits_from_bytes(ptr0, len0);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    mem() {\n        var ret = wasm.exunits_mem(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    steps() {\n        var ret = wasm.exunits_steps(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} mem\n    * @param {BigNum} steps\n    * @returns {ExUnits}\n    */\n    static new(mem, steps) {\n        _assertClass(mem, BigNum);\n        _assertClass(steps, BigNum);\n        var ret = wasm.exunits_new(mem.ptr, steps.ptr);\n        return ExUnits.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GeneralTransactionMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GeneralTransactionMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_generaltransactionmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.generaltransactionmetadata_from_bytes(ptr0, len0);\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata}\n    */\n    static new() {\n        var ret = wasm.generaltransactionmetadata_new();\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.generaltransactionmetadata_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, BigNum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.generaltransactionmetadata_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key\n    * @returns {TransactionMetadatum | undefined}\n    */\n    get(key) {\n        _assertClass(key, BigNum);\n        var ret = wasm.generaltransactionmetadata_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    keys() {\n        var ret = wasm.generaltransactionmetadata_keys(this.ptr);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisDelegateHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisDelegateHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesisdelegatehash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesisdelegatehash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.genesisdelegatehash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_bech32(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_bytes(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.genesishash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_bech32(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_bytes(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishashes_from_bytes(ptr0, len0);\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    static new() {\n        var ret = wasm.genesishashes_new();\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.genesishashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {GenesisHash}\n    */\n    get(index) {\n        var ret = wasm.genesishashes_get(this.ptr, index);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, GenesisHash);\n        wasm.genesishashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class GenesisKeyDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisKeyDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesiskeydelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesiskeydelegation_from_bytes(ptr0, len0);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHash}\n    */\n    genesishash() {\n        var ret = wasm.genesiskeydelegation_genesishash(this.ptr);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisDelegateHash}\n    */\n    genesis_delegate_hash() {\n        var ret = wasm.genesiskeydelegation_genesis_delegate_hash(this.ptr);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = wasm.genesiskeydelegation_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} genesishash\n    * @param {GenesisDelegateHash} genesis_delegate_hash\n    * @param {VRFKeyHash} vrf_keyhash\n    * @returns {GenesisKeyDelegation}\n    */\n    static new(genesishash, genesis_delegate_hash, vrf_keyhash) {\n        _assertClass(genesishash, GenesisHash);\n        _assertClass(genesis_delegate_hash, GenesisDelegateHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        var ret = wasm.genesiskeydelegation_new(genesishash.ptr, genesis_delegate_hash.ptr, vrf_keyhash.ptr);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Header {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Header.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_header_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Header}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.header_from_bytes(ptr0, len0);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderBody}\n    */\n    header_body() {\n        var ret = wasm.header_header_body(this.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {KESSignature}\n    */\n    body_signature() {\n        var ret = wasm.header_body_signature(this.ptr);\n        return KESSignature.__wrap(ret);\n    }\n    /**\n    * @param {HeaderBody} header_body\n    * @param {KESSignature} body_signature\n    * @returns {Header}\n    */\n    static new(header_body, body_signature) {\n        _assertClass(header_body, HeaderBody);\n        _assertClass(body_signature, KESSignature);\n        var ret = wasm.header_new(header_body.ptr, body_signature.ptr);\n        return Header.__wrap(ret);\n    }\n}\n/**\n*/\nexport class HeaderBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headerbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headerbody_from_bytes(ptr0, len0);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_number() {\n        var ret = wasm.headerbody_block_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.headerbody_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash | undefined}\n    */\n    prev_hash() {\n        var ret = wasm.headerbody_prev_hash(this.ptr);\n        return ret === 0 ? undefined : BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    issuer_vkey() {\n        var ret = wasm.headerbody_issuer_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFVKey}\n    */\n    vrf_vkey() {\n        var ret = wasm.headerbody_vrf_vkey(this.ptr);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFCert}\n    */\n    nonce_vrf() {\n        var ret = wasm.headerbody_nonce_vrf(this.ptr);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {VRFCert}\n    */\n    leader_vrf() {\n        var ret = wasm.headerbody_leader_vrf(this.ptr);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_body_size() {\n        var ret = wasm.headerbody_block_body_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash}\n    */\n    block_body_hash() {\n        var ret = wasm.headerbody_block_body_hash(this.ptr);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {OperationalCert}\n    */\n    operational_cert() {\n        var ret = wasm.headerbody_operational_cert(this.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersion}\n    */\n    protocol_version() {\n        var ret = wasm.headerbody_protocol_version(this.ptr);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {number} block_number\n    * @param {number} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} nonce_vrf\n    * @param {VRFCert} leader_vrf\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, nonce_vrf, leader_vrf, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.ptr;\n            prev_hash.ptr = 0;\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(nonce_vrf, VRFCert);\n        _assertClass(leader_vrf, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        var ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, nonce_vrf.ptr, leader_vrf.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ret = wasm.int_new(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ret = wasm.int_new_negative(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Ipv4 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv4.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv4_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv4}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_from_bytes(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv4}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_new(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Ipv6 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv6.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv6_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv6}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_from_bytes(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv6}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_new(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class KESSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kessignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kessignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kessignature_from_bytes(ptr0, len0);\n        return KESSignature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class KESVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kesvkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kesvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.kesvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {KESVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_bech32(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_bytes(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Language {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Language.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_language_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Language}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.language_from_bytes(ptr0, len0);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v1() {\n        var ret = wasm.language_new_plutus_v1();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.language_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Languages {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Languages.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_languages_free(ptr);\n    }\n    /**\n    * @returns {Languages}\n    */\n    static new() {\n        var ret = wasm.languages_new();\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.languages_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Language}\n    */\n    get(index) {\n        var ret = wasm.languages_get(this.ptr, index);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @param {Language} elem\n    */\n    add(elem) {\n        _assertClass(elem, Language);\n        var ptr0 = elem.ptr;\n        elem.ptr = 0;\n        wasm.languages_add(this.ptr, ptr0);\n    }\n}\n/**\n*/\nexport class LegacyDaedalusPrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LegacyDaedalusPrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_legacydaedalusprivatekey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {LegacyDaedalusPrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.legacydaedalusprivatekey_from_bytes(ptr0, len0);\n        return LegacyDaedalusPrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class LinearFee {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LinearFee.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_linearfee_free(ptr);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    constant() {\n        var ret = wasm.linearfee_constant(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coefficient() {\n        var ret = wasm.linearfee_coefficient(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coefficient\n    * @param {BigNum} constant\n    * @returns {LinearFee}\n    */\n    static new(coefficient, constant) {\n        _assertClass(coefficient, BigNum);\n        _assertClass(constant, BigNum);\n        var ret = wasm.linearfee_new(coefficient.ptr, constant.ptr);\n        return LinearFee.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MIRToStakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MIRToStakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mirtostakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mirtostakecredentials_from_bytes(ptr0, len0);\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials}\n    */\n    static new() {\n        var ret = wasm.mirtostakecredentials_new();\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mirtostakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @param {Int} delta\n    * @returns {Int | undefined}\n    */\n    insert(cred, delta) {\n        _assertClass(cred, StakeCredential);\n        _assertClass(delta, Int);\n        var ret = wasm.mirtostakecredentials_insert(this.ptr, cred.ptr, delta.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @returns {Int | undefined}\n    */\n    get(cred) {\n        _assertClass(cred, StakeCredential);\n        var ret = wasm.mirtostakecredentials_get(this.ptr, cred.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    keys() {\n        var ret = wasm.mirtostakecredentials_keys(this.ptr);\n        return StakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MetadataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatalist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatalist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatalist_from_bytes(ptr0, len0);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    static new() {\n        var ret = wasm.metadatalist_new();\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.metadatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionMetadatum}\n    */\n    get(index) {\n        var ret = wasm.metadatalist_get(this.ptr, index);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionMetadatum);\n        wasm.metadatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class MetadataMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatamap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_from_bytes(ptr0, len0);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    static new() {\n        var ret = wasm.metadatamap_new();\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.metadatamap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, TransactionMetadatum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_str(key, value) {\n        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert_str(this.ptr, ptr0, len0, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_i32(key, value) {\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert_i32(this.ptr, key, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {TransactionMetadatum}\n    */\n    get(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = wasm.metadatamap_get(this.ptr, key.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @returns {TransactionMetadatum}\n    */\n    get_str(key) {\n        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_get_str(this.ptr, ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @returns {TransactionMetadatum}\n    */\n    get_i32(key) {\n        var ret = wasm.metadatamap_get_i32(this.ptr, key);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {boolean}\n    */\n    has(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = wasm.metadatamap_has(this.ptr, key.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    keys() {\n        var ret = wasm.metadatamap_keys(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Mint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Mint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Mint}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mint_from_bytes(ptr0, len0);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {Mint}\n    */\n    static new() {\n        var ret = wasm.mint_new();\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mint_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {MintAssets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        var ret = wasm.mint_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {MintAssets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = wasm.mint_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = wasm.mint_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MintAssets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MintAssets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintassets_free(ptr);\n    }\n    /**\n    * @returns {MintAssets}\n    */\n    static new() {\n        var ret = wasm.mintassets_new();\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mintassets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {Int | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, Int);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = wasm.mintassets_insert(this.ptr, key.ptr, ptr0);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {Int | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = wasm.mintassets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = wasm.mintassets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MoveInstantaneousReward {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousReward.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousreward_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousreward_from_bytes(ptr0, len0);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {BigNum} amount\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_other_pot(pot, amount) {\n        _assertClass(amount, BigNum);\n        var ret = wasm.moveinstantaneousreward_new_to_other_pot(pot, amount.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {MIRToStakeCredentials} amounts\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_stake_creds(pot, amounts) {\n        _assertClass(amounts, MIRToStakeCredentials);\n        var ret = wasm.moveinstantaneousreward_new_to_stake_creds(pot, amounts.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    pot() {\n        var ret = wasm.moveinstantaneousreward_pot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.moveinstantaneousreward_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_to_other_pot() {\n        var ret = wasm.moveinstantaneousreward_as_to_other_pot(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials | undefined}\n    */\n    as_to_stake_creds() {\n        var ret = wasm.moveinstantaneousreward_as_to_stake_creds(this.ptr);\n        return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MoveInstantaneousRewardsCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousRewardsCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousrewardscert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousrewardscert_from_bytes(ptr0, len0);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousReward}\n    */\n    move_instantaneous_reward() {\n        var ret = wasm.moveinstantaneousrewardscert_move_instantaneous_reward(this.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousReward} move_instantaneous_reward\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static new(move_instantaneous_reward) {\n        _assertClass(move_instantaneous_reward, MoveInstantaneousReward);\n        var ret = wasm.moveinstantaneousrewardscert_new(move_instantaneous_reward.ptr);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MultiAsset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiAsset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multiasset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiAsset}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multiasset_from_bytes(ptr0, len0);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {MultiAsset}\n    */\n    static new() {\n        var ret = wasm.multiasset_new();\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.multiasset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {Assets} value\n    * @returns {Assets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, Assets);\n        var ret = wasm.multiasset_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {Assets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = wasm.multiasset_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = wasm.multiasset_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * removes an asset from the list if the result is 0 or less\n    * @param {MultiAsset} rhs_ma\n    * @returns {MultiAsset}\n    */\n    sub(rhs_ma) {\n        _assertClass(rhs_ma, MultiAsset);\n        var ret = wasm.multiasset_sub(this.ptr, rhs_ma.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MultiHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multihostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multihostname_from_bytes(ptr0, len0);\n        return MultiHostName.__wrap(ret);\n    }\n    /**\n    * @returns {DNSRecordSRV}\n    */\n    dns_name() {\n        var ret = wasm.multihostname_dns_name(this.ptr);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {DNSRecordSRV} dns_name\n    * @returns {MultiHostName}\n    */\n    static new(dns_name) {\n        _assertClass(dns_name, DNSRecordSRV);\n        var ret = wasm.multihostname_new(dns_name.ptr);\n        return MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class NativeScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NativeScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nativescript_from_bytes(ptr0, len0);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {number} namespace\n    * @returns {Ed25519KeyHash}\n    */\n    hash(namespace) {\n        var ret = wasm.nativescript_hash(this.ptr, namespace);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptPubkey} script_pubkey\n    * @returns {NativeScript}\n    */\n    static new_script_pubkey(script_pubkey) {\n        _assertClass(script_pubkey, ScriptPubkey);\n        var ret = wasm.nativescript_new_script_pubkey(script_pubkey.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAll} script_all\n    * @returns {NativeScript}\n    */\n    static new_script_all(script_all) {\n        _assertClass(script_all, ScriptAll);\n        var ret = wasm.nativescript_new_script_all(script_all.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAny} script_any\n    * @returns {NativeScript}\n    */\n    static new_script_any(script_any) {\n        _assertClass(script_any, ScriptAny);\n        var ret = wasm.nativescript_new_script_any(script_any.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptNOfK} script_n_of_k\n    * @returns {NativeScript}\n    */\n    static new_script_n_of_k(script_n_of_k) {\n        _assertClass(script_n_of_k, ScriptNOfK);\n        var ret = wasm.nativescript_new_script_n_of_k(script_n_of_k.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockStart} timelock_start\n    * @returns {NativeScript}\n    */\n    static new_timelock_start(timelock_start) {\n        _assertClass(timelock_start, TimelockStart);\n        var ret = wasm.nativescript_new_timelock_start(timelock_start.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockExpiry} timelock_expiry\n    * @returns {NativeScript}\n    */\n    static new_timelock_expiry(timelock_expiry) {\n        _assertClass(timelock_expiry, TimelockExpiry);\n        var ret = wasm.nativescript_new_timelock_expiry(timelock_expiry.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.nativescript_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ScriptPubkey | undefined}\n    */\n    as_script_pubkey() {\n        var ret = wasm.nativescript_as_script_pubkey(this.ptr);\n        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAll | undefined}\n    */\n    as_script_all() {\n        var ret = wasm.nativescript_as_script_all(this.ptr);\n        return ret === 0 ? undefined : ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAny | undefined}\n    */\n    as_script_any() {\n        var ret = wasm.nativescript_as_script_any(this.ptr);\n        return ret === 0 ? undefined : ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptNOfK | undefined}\n    */\n    as_script_n_of_k() {\n        var ret = wasm.nativescript_as_script_n_of_k(this.ptr);\n        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockStart | undefined}\n    */\n    as_timelock_start() {\n        var ret = wasm.nativescript_as_timelock_start(this.ptr);\n        return ret === 0 ? undefined : TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockExpiry | undefined}\n    */\n    as_timelock_expiry() {\n        var ret = wasm.nativescript_as_timelock_expiry(this.ptr);\n        return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nexport class NativeScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescripts_free(ptr);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    static new() {\n        var ret = wasm.nativescripts_new();\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.nativescripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {NativeScript}\n    */\n    get(index) {\n        var ret = wasm.nativescripts_get(this.ptr, index);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {NativeScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, NativeScript);\n        wasm.nativescripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class NetworkId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkid_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NetworkId}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkid_from_bytes(ptr0, len0);\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static testnet() {\n        var ret = wasm.networkid_testnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static mainnet() {\n        var ret = wasm.networkid_mainnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.networkid_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class NetworkInfo {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkInfo.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkinfo_free(ptr);\n    }\n    /**\n    * @param {number} network_id\n    * @param {number} protocol_magic\n    * @returns {NetworkInfo}\n    */\n    static new(network_id, protocol_magic) {\n        var ret = wasm.networkinfo_new(network_id, protocol_magic);\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.networkinfo_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    protocol_magic() {\n        var ret = wasm.networkinfo_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static testnet() {\n        var ret = wasm.networkinfo_testnet();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static mainnet() {\n        var ret = wasm.networkinfo_mainnet();\n        return NetworkInfo.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Nonce {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Nonce.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nonce_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Nonce}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_from_bytes(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Nonce}\n    */\n    static new_identity() {\n        var ret = wasm.nonce_new_identity();\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} hash\n    * @returns {Nonce}\n    */\n    static new_from_hash(hash) {\n        var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_new_from_hash(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    get_hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_get_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class OperationalCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(OperationalCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_operationalcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {OperationalCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.operationalcert_from_bytes(ptr0, len0);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {KESVKey}\n    */\n    hot_vkey() {\n        var ret = wasm.operationalcert_hot_vkey(this.ptr);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    sequence_number() {\n        var ret = wasm.operationalcert_sequence_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kes_period() {\n        var ret = wasm.operationalcert_kes_period(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    sigma() {\n        var ret = wasm.operationalcert_sigma(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {KESVKey} hot_vkey\n    * @param {number} sequence_number\n    * @param {number} kes_period\n    * @param {Ed25519Signature} sigma\n    * @returns {OperationalCert}\n    */\n    static new(hot_vkey, sequence_number, kes_period, sigma) {\n        _assertClass(hot_vkey, KESVKey);\n        _assertClass(sigma, Ed25519Signature);\n        var ret = wasm.operationalcert_new(hot_vkey.ptr, sequence_number, kes_period, sigma.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_from_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {ConstrPlutusData} constr_plutus_data\n    * @returns {PlutusData}\n    */\n    static new_constr_plutus_data(constr_plutus_data) {\n        _assertClass(constr_plutus_data, ConstrPlutusData);\n        var ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusMap} map\n    * @returns {PlutusData}\n    */\n    static new_map(map) {\n        _assertClass(map, PlutusMap);\n        var ret = wasm.plutusdata_new_map(map.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} list\n    * @returns {PlutusData}\n    */\n    static new_list(list) {\n        _assertClass(list, PlutusList);\n        var ret = wasm.plutusdata_new_list(list.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} integer\n    * @returns {PlutusData}\n    */\n    static new_integer(integer) {\n        _assertClass(integer, BigInt);\n        var ret = wasm.plutusdata_new_integer(integer.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_new_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.plutusdata_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ConstrPlutusData | undefined}\n    */\n    as_constr_plutus_data() {\n        var ret = wasm.plutusdata_as_constr_plutus_data(this.ptr);\n        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap | undefined}\n    */\n    as_map() {\n        var ret = wasm.plutusdata_as_map(this.ptr);\n        return ret === 0 ? undefined : PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    as_list() {\n        var ret = wasm.plutusdata_as_list(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt | undefined}\n    */\n    as_integer() {\n        var ret = wasm.plutusdata_as_integer(this.ptr);\n        return ret === 0 ? undefined : BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class PlutusList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuslist_free(ptr);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    static new() {\n        var ret = wasm.plutuslist_new();\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutuslist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusData}\n    */\n    get(index) {\n        var ret = wasm.plutuslist_get(this.ptr, index);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusData);\n        wasm.plutuslist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class PlutusMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusmap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusmap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusmap_from_bytes(ptr0, len0);\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap}\n    */\n    static new() {\n        var ret = wasm.plutusmap_new();\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutusmap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {PlutusData} key\n    * @param {PlutusData} value\n    * @returns {PlutusData | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, PlutusData);\n        _assertClass(value, PlutusData);\n        var ret = wasm.plutusmap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} key\n    * @returns {PlutusData | undefined}\n    */\n    get(key) {\n        _assertClass(key, PlutusData);\n        var ret = wasm.plutusmap_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    keys() {\n        var ret = wasm.plutusmap_keys(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_from_bytes(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_new(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class PlutusScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscripts_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScripts}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscripts_from_bytes(ptr0, len0);\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScripts}\n    */\n    static new() {\n        var ret = wasm.plutusscripts_new();\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutusscripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusScript}\n    */\n    get(index) {\n        var ret = wasm.plutusscripts_get(this.ptr, index);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusScript);\n        wasm.plutusscripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Pointer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Pointer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointer_free(ptr);\n    }\n    /**\n    * @param {number} slot\n    * @param {number} tx_index\n    * @param {number} cert_index\n    * @returns {Pointer}\n    */\n    static new(slot, tx_index, cert_index) {\n        var ret = wasm.pointer_new(slot, tx_index, cert_index);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.pointer_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    tx_index() {\n        var ret = wasm.pointer_tx_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    cert_index() {\n        var ret = wasm.pointer_cert_index(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class PointerAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PointerAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointeraddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {Pointer} stake\n    * @returns {PointerAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, Pointer);\n        var ret = wasm.pointeraddress_new(network, payment.ptr, stake.ptr);\n        return PointerAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.pointeraddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Pointer}\n    */\n    stake_pointer() {\n        var ret = wasm.pointeraddress_stake_pointer(this.ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.pointeraddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {PointerAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.pointeraddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : PointerAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadata_from_bytes(ptr0, len0);\n        return PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {URL}\n    */\n    url() {\n        var ret = wasm.poolmetadata_url(this.ptr);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadataHash}\n    */\n    pool_metadata_hash() {\n        var ret = wasm.poolmetadata_pool_metadata_hash(this.ptr);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {URL} url\n    * @param {PoolMetadataHash} pool_metadata_hash\n    * @returns {PoolMetadata}\n    */\n    static new(url, pool_metadata_hash) {\n        _assertClass(url, URL);\n        _assertClass(pool_metadata_hash, PoolMetadataHash);\n        var ret = wasm.poolmetadata_new(url.ptr, pool_metadata_hash.ptr);\n        return PoolMetadata.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolMetadataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {PoolMetadataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_bech32(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_bytes(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolParams {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolParams.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolparams_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolParams}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolparams_from_bytes(ptr0, len0);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    operator() {\n        var ret = wasm.poolparams_operator(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = wasm.poolparams_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    pledge() {\n        var ret = wasm.poolparams_pledge(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cost() {\n        var ret = wasm.poolparams_cost(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    margin() {\n        var ret = wasm.poolparams_margin(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddress}\n    */\n    reward_account() {\n        var ret = wasm.poolparams_reward_account(this.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    pool_owners() {\n        var ret = wasm.poolparams_pool_owners(this.ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    relays() {\n        var ret = wasm.poolparams_relays(this.ptr);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadata | undefined}\n    */\n    pool_metadata() {\n        var ret = wasm.poolparams_pool_metadata(this.ptr);\n        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} operator\n    * @param {VRFKeyHash} vrf_keyhash\n    * @param {BigNum} pledge\n    * @param {BigNum} cost\n    * @param {UnitInterval} margin\n    * @param {RewardAddress} reward_account\n    * @param {Ed25519KeyHashes} pool_owners\n    * @param {Relays} relays\n    * @param {PoolMetadata | undefined} pool_metadata\n    * @returns {PoolParams}\n    */\n    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {\n        _assertClass(operator, Ed25519KeyHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        _assertClass(pledge, BigNum);\n        _assertClass(cost, BigNum);\n        _assertClass(margin, UnitInterval);\n        _assertClass(reward_account, RewardAddress);\n        _assertClass(pool_owners, Ed25519KeyHashes);\n        _assertClass(relays, Relays);\n        let ptr0 = 0;\n        if (!isLikeNone(pool_metadata)) {\n            _assertClass(pool_metadata, PoolMetadata);\n            ptr0 = pool_metadata.ptr;\n            pool_metadata.ptr = 0;\n        }\n        var ret = wasm.poolparams_new(operator.ptr, vrf_keyhash.ptr, pledge.ptr, cost.ptr, margin.ptr, reward_account.ptr, pool_owners.ptr, relays.ptr, ptr0);\n        return PoolParams.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolregistration_from_bytes(ptr0, len0);\n        return PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolParams}\n    */\n    pool_params() {\n        var ret = wasm.poolregistration_pool_params(this.ptr);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @param {PoolParams} pool_params\n    * @returns {PoolRegistration}\n    */\n    static new(pool_params) {\n        _assertClass(pool_params, PoolParams);\n        var ret = wasm.poolregistration_new(pool_params.ptr);\n        return PoolRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolRetirement {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRetirement.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolretirement_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRetirement}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolretirement_from_bytes(ptr0, len0);\n        return PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = wasm.poolretirement_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = wasm.poolretirement_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {number} epoch\n    * @returns {PoolRetirement}\n    */\n    static new(pool_keyhash, epoch) {\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = wasm.poolretirement_new(pool_keyhash.ptr, epoch);\n        return PoolRetirement.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_public() {\n        var ret = wasm.privatekey_to_public(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519() {\n        var ret = wasm.privatekey_generate_ed25519();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519extended() {\n        var ret = wasm.privatekey_generate_ed25519extended();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_extended_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_extended_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_normal_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_normal_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} message\n    * @returns {Ed25519Signature}\n    */\n    sign(message) {\n        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_sign(this.ptr, ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProposedProtocolParameterUpdates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProposedProtocolParameterUpdates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proposedprotocolparameterupdates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.proposedprotocolparameterupdates_from_bytes(ptr0, len0);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static new() {\n        var ret = wasm.proposedprotocolparameterupdates_new();\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.proposedprotocolparameterupdates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {GenesisHash} key\n    * @param {ProtocolParamUpdate} value\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, GenesisHash);\n        _assertClass(value, ProtocolParamUpdate);\n        var ret = wasm.proposedprotocolparameterupdates_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} key\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    get(key) {\n        _assertClass(key, GenesisHash);\n        var ret = wasm.proposedprotocolparameterupdates_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    keys() {\n        var ret = wasm.proposedprotocolparameterupdates_keys(this.ptr);\n        return GenesisHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolParamUpdate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolParamUpdate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolparamupdate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolparamupdate_from_bytes(ptr0, len0);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_a\n    */\n    set_minfee_a(minfee_a) {\n        _assertClass(minfee_a, BigNum);\n        wasm.protocolparamupdate_set_minfee_a(this.ptr, minfee_a.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_a() {\n        var ret = wasm.protocolparamupdate_minfee_a(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_b\n    */\n    set_minfee_b(minfee_b) {\n        _assertClass(minfee_b, BigNum);\n        wasm.protocolparamupdate_set_minfee_b(this.ptr, minfee_b.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_b() {\n        var ret = wasm.protocolparamupdate_minfee_b(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_block_body_size\n    */\n    set_max_block_body_size(max_block_body_size) {\n        wasm.protocolparamupdate_set_max_block_body_size(this.ptr, max_block_body_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_body_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_body_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_tx_size\n    */\n    set_max_tx_size(max_tx_size) {\n        wasm.protocolparamupdate_set_max_tx_size(this.ptr, max_tx_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_tx_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_tx_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_block_header_size\n    */\n    set_max_block_header_size(max_block_header_size) {\n        wasm.protocolparamupdate_set_max_block_header_size(this.ptr, max_block_header_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_header_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_header_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} key_deposit\n    */\n    set_key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        wasm.protocolparamupdate_set_key_deposit(this.ptr, key_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    key_deposit() {\n        var ret = wasm.protocolparamupdate_key_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    */\n    set_pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        wasm.protocolparamupdate_set_pool_deposit(this.ptr, pool_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    pool_deposit() {\n        var ret = wasm.protocolparamupdate_pool_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_epoch\n    */\n    set_max_epoch(max_epoch) {\n        wasm.protocolparamupdate_set_max_epoch(this.ptr, max_epoch);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_epoch() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_epoch(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} n_opt\n    */\n    set_n_opt(n_opt) {\n        wasm.protocolparamupdate_set_n_opt(this.ptr, n_opt);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    n_opt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_n_opt(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} pool_pledge_influence\n    */\n    set_pool_pledge_influence(pool_pledge_influence) {\n        _assertClass(pool_pledge_influence, UnitInterval);\n        wasm.protocolparamupdate_set_pool_pledge_influence(this.ptr, pool_pledge_influence.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    pool_pledge_influence() {\n        var ret = wasm.protocolparamupdate_pool_pledge_influence(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} expansion_rate\n    */\n    set_expansion_rate(expansion_rate) {\n        _assertClass(expansion_rate, UnitInterval);\n        wasm.protocolparamupdate_set_expansion_rate(this.ptr, expansion_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    expansion_rate() {\n        var ret = wasm.protocolparamupdate_expansion_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} treasury_growth_rate\n    */\n    set_treasury_growth_rate(treasury_growth_rate) {\n        _assertClass(treasury_growth_rate, UnitInterval);\n        wasm.protocolparamupdate_set_treasury_growth_rate(this.ptr, treasury_growth_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    treasury_growth_rate() {\n        var ret = wasm.protocolparamupdate_treasury_growth_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} d\n    */\n    set_d(d) {\n        _assertClass(d, UnitInterval);\n        wasm.protocolparamupdate_set_d(this.ptr, d.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    d() {\n        var ret = wasm.protocolparamupdate_d(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {Nonce} extra_entropy\n    */\n    set_extra_entropy(extra_entropy) {\n        _assertClass(extra_entropy, Nonce);\n        wasm.protocolparamupdate_set_extra_entropy(this.ptr, extra_entropy.ptr);\n    }\n    /**\n    * @returns {Nonce | undefined}\n    */\n    extra_entropy() {\n        var ret = wasm.protocolparamupdate_extra_entropy(this.ptr);\n        return ret === 0 ? undefined : Nonce.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersions} protocol_version\n    */\n    set_protocol_version(protocol_version) {\n        _assertClass(protocol_version, ProtocolVersions);\n        wasm.protocolparamupdate_set_protocol_version(this.ptr, protocol_version.ptr);\n    }\n    /**\n    * @returns {ProtocolVersions | undefined}\n    */\n    protocol_version() {\n        var ret = wasm.protocolparamupdate_protocol_version(this.ptr);\n        return ret === 0 ? undefined : ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} min_pool_cost\n    */\n    set_min_pool_cost(min_pool_cost) {\n        _assertClass(min_pool_cost, BigNum);\n        wasm.protocolparamupdate_set_min_pool_cost(this.ptr, min_pool_cost.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    min_pool_cost() {\n        var ret = wasm.protocolparamupdate_min_pool_cost(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ada_per_utxo_byte\n    */\n    set_ada_per_utxo_byte(ada_per_utxo_byte) {\n        _assertClass(ada_per_utxo_byte, BigNum);\n        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.ptr, ada_per_utxo_byte.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ada_per_utxo_byte() {\n        var ret = wasm.protocolparamupdate_ada_per_utxo_byte(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Costmdls} cost_models\n    */\n    set_cost_models(cost_models) {\n        _assertClass(cost_models, Costmdls);\n        wasm.protocolparamupdate_set_cost_models(this.ptr, cost_models.ptr);\n    }\n    /**\n    * @returns {Costmdls | undefined}\n    */\n    cost_models() {\n        var ret = wasm.protocolparamupdate_cost_models(this.ptr);\n        return ret === 0 ? undefined : Costmdls.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} execution_costs\n    */\n    set_execution_costs(execution_costs) {\n        _assertClass(execution_costs, ExUnitPrices);\n        wasm.protocolparamupdate_set_execution_costs(this.ptr, execution_costs.ptr);\n    }\n    /**\n    * @returns {ExUnitPrices | undefined}\n    */\n    execution_costs() {\n        var ret = wasm.protocolparamupdate_execution_costs(this.ptr);\n        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_tx_ex_units\n    */\n    set_max_tx_ex_units(max_tx_ex_units) {\n        _assertClass(max_tx_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_tx_ex_units(this.ptr, max_tx_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_tx_ex_units() {\n        var ret = wasm.protocolparamupdate_max_tx_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_block_ex_units\n    */\n    set_max_block_ex_units(max_block_ex_units) {\n        _assertClass(max_block_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_block_ex_units(this.ptr, max_block_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_block_ex_units() {\n        var ret = wasm.protocolparamupdate_max_block_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    */\n    set_max_value_size(max_value_size) {\n        wasm.protocolparamupdate_set_max_value_size(this.ptr, max_value_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_value_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_value_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProtocolParamUpdate}\n    */\n    static new() {\n        var ret = wasm.protocolparamupdate_new();\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolVersion {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersion.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolversion_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersion}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversion_from_bytes(ptr0, len0);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    major() {\n        var ret = wasm.protocolversion_major(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    minor() {\n        var ret = wasm.protocolversion_minor(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} major\n    * @param {number} minor\n    * @returns {ProtocolVersion}\n    */\n    static new(major, minor) {\n        var ret = wasm.protocolversion_new(major, minor);\n        return ProtocolVersion.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolVersions {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersions.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolversions_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversions_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersions}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversions_from_bytes(ptr0, len0);\n        return ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersions}\n    */\n    static new() {\n        var ret = wasm.protocolversions_new();\n        return ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.protocolversions_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ProtocolVersion}\n    */\n    get(index) {\n        var ret = wasm.protocolversions_get(this.ptr, index);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersion} elem\n    */\n    add(elem) {\n        _assertClass(elem, ProtocolVersion);\n        wasm.protocolversions_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ED25519 key used as public key\n*/\nexport class PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr);\n    }\n    /**\n    * Get public key from its bech32 representation\n    * Example:\n    * ```javascript\n    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_bech32(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_bytes(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @param {Ed25519Signature} signature\n    * @returns {boolean}\n    */\n    verify(data, signature) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Ed25519Signature);\n        var ret = wasm.publickey_verify(this.ptr, ptr0, len0, signature.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    hash() {\n        var ret = wasm.publickey_hash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PublicKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickeys_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.publickeys_new();\n        return PublicKeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    size() {\n        var ret = wasm.publickeys_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PublicKey}\n    */\n    get(index) {\n        var ret = wasm.publickeys_get(this.ptr, index);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} key\n    */\n    add(key) {\n        _assertClass(key, PublicKey);\n        wasm.publickeys_add(this.ptr, key.ptr);\n    }\n}\n/**\n*/\nexport class Redeemer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemer_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemer}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemer_from_bytes(ptr0, len0);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    tag() {\n        var ret = wasm.redeemer_tag(this.ptr);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    index() {\n        var ret = wasm.redeemer_index(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData}\n    */\n    data() {\n        var ret = wasm.redeemer_data(this.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    ex_units() {\n        var ret = wasm.redeemer_ex_units(this.ptr);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {RedeemerTag} tag\n    * @param {BigNum} index\n    * @param {PlutusData} data\n    * @param {ExUnits} ex_units\n    * @returns {Redeemer}\n    */\n    static new(tag, index, data, ex_units) {\n        _assertClass(tag, RedeemerTag);\n        _assertClass(index, BigNum);\n        _assertClass(data, PlutusData);\n        _assertClass(ex_units, ExUnits);\n        var ret = wasm.redeemer_new(tag.ptr, index.ptr, data.ptr, ex_units.ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RedeemerTag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RedeemerTag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemertag_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RedeemerTag}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemertag_from_bytes(ptr0, len0);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_spend() {\n        var ret = wasm.redeemertag_new_spend();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_mint() {\n        var ret = wasm.redeemertag_new_mint();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_cert() {\n        var ret = wasm.redeemertag_new_cert();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_reward() {\n        var ret = wasm.redeemertag_new_reward();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.redeemertag_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Redeemers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemers_free(ptr);\n    }\n    /**\n    * @returns {Redeemers}\n    */\n    static new() {\n        var ret = wasm.redeemers_new();\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.redeemers_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Redeemer}\n    */\n    get(index) {\n        var ret = wasm.redeemers_get(this.ptr, index);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @param {Redeemer} elem\n    */\n    add(elem) {\n        _assertClass(elem, Redeemer);\n        wasm.redeemers_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Relay {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relay.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relay_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relay}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relay_from_bytes(ptr0, len0);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostAddr} single_host_addr\n    * @returns {Relay}\n    */\n    static new_single_host_addr(single_host_addr) {\n        _assertClass(single_host_addr, SingleHostAddr);\n        var ret = wasm.relay_new_single_host_addr(single_host_addr.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostName} single_host_name\n    * @returns {Relay}\n    */\n    static new_single_host_name(single_host_name) {\n        _assertClass(single_host_name, SingleHostName);\n        var ret = wasm.relay_new_single_host_name(single_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {MultiHostName} multi_host_name\n    * @returns {Relay}\n    */\n    static new_multi_host_name(multi_host_name) {\n        _assertClass(multi_host_name, MultiHostName);\n        var ret = wasm.relay_new_multi_host_name(multi_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.relay_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {SingleHostAddr | undefined}\n    */\n    as_single_host_addr() {\n        var ret = wasm.relay_as_single_host_addr(this.ptr);\n        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {SingleHostName | undefined}\n    */\n    as_single_host_name() {\n        var ret = wasm.relay_as_single_host_name(this.ptr);\n        return ret === 0 ? undefined : SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {MultiHostName | undefined}\n    */\n    as_multi_host_name() {\n        var ret = wasm.relay_as_multi_host_name(this.ptr);\n        return ret === 0 ? undefined : MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Relays {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relays.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relays_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relays}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relays_from_bytes(ptr0, len0);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    static new() {\n        var ret = wasm.relays_new();\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.relays_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Relay}\n    */\n    get(index) {\n        var ret = wasm.relays_get(this.ptr, index);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {Relay} elem\n    */\n    add(elem) {\n        _assertClass(elem, Relay);\n        wasm.relays_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class RewardAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {RewardAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = wasm.rewardaddress_new(network, payment.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.rewardaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.rewardaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {RewardAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.rewardaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : RewardAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RewardAddresses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddresses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddresses_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RewardAddresses}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rewardaddresses_from_bytes(ptr0, len0);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    static new() {\n        var ret = wasm.rewardaddresses_new();\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.rewardaddresses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {RewardAddress}\n    */\n    get(index) {\n        var ret = wasm.rewardaddresses_get(this.ptr, index);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} elem\n    */\n    add(elem) {\n        _assertClass(elem, RewardAddress);\n        wasm.rewardaddresses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ScriptAll {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAll.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptall_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAll}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptall_from_bytes(ptr0, len0);\n        return ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptall_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAll}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptall_new(native_scripts.ptr);\n        return ScriptAll.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptAny {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAny.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptany_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAny}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptany_from_bytes(ptr0, len0);\n        return ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptany_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAny}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptany_new(native_scripts.ptr);\n        return ScriptAny.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptdatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptdatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.scriptdatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_bech32(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_bytes(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.scripthash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_bech32(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_bytes(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthashes_from_bytes(ptr0, len0);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    static new() {\n        var ret = wasm.scripthashes_new();\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.scripthashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ScriptHash}\n    */\n    get(index) {\n        var ret = wasm.scripthashes_get(this.ptr, index);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, ScriptHash);\n        wasm.scripthashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ScriptNOfK {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptNOfK.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptnofk_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptNOfK}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptnofk_from_bytes(ptr0, len0);\n        return ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    n() {\n        var ret = wasm.scriptnofk_n(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptnofk_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {number} n\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptNOfK}\n    */\n    static new(n, native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptnofk_new(n, native_scripts.ptr);\n        return ScriptNOfK.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptPubkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptPubkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptpubkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptPubkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptpubkey_from_bytes(ptr0, len0);\n        return ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    addr_keyhash() {\n        var ret = wasm.scriptpubkey_addr_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} addr_keyhash\n    * @returns {ScriptPubkey}\n    */\n    static new(addr_keyhash) {\n        _assertClass(addr_keyhash, Ed25519KeyHash);\n        var ret = wasm.scriptpubkey_new(addr_keyhash.ptr);\n        return ScriptPubkey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SingleHostAddr {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostAddr.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostaddr_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostAddr}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostaddr_from_bytes(ptr0, len0);\n        return SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = wasm.singlehostaddr_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {Ipv4 | undefined}\n    */\n    ipv4() {\n        var ret = wasm.singlehostaddr_ipv4(this.ptr);\n        return ret === 0 ? undefined : Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Ipv6 | undefined}\n    */\n    ipv6() {\n        var ret = wasm.singlehostaddr_ipv6(this.ptr);\n        return ret === 0 ? undefined : Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {Ipv4 | undefined} ipv4\n    * @param {Ipv6 | undefined} ipv6\n    * @returns {SingleHostAddr}\n    */\n    static new(port, ipv4, ipv6) {\n        let ptr0 = 0;\n        if (!isLikeNone(ipv4)) {\n            _assertClass(ipv4, Ipv4);\n            ptr0 = ipv4.ptr;\n            ipv4.ptr = 0;\n        }\n        let ptr1 = 0;\n        if (!isLikeNone(ipv6)) {\n            _assertClass(ipv6, Ipv6);\n            ptr1 = ipv6.ptr;\n            ipv6.ptr = 0;\n        }\n        var ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);\n        return SingleHostAddr.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SingleHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostname_from_bytes(ptr0, len0);\n        return SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = wasm.singlehostname_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {DNSRecordAorAAAA}\n    */\n    dns_name() {\n        var ret = wasm.singlehostname_dns_name(this.ptr);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {DNSRecordAorAAAA} dns_name\n    * @returns {SingleHostName}\n    */\n    static new(port, dns_name) {\n        _assertClass(dns_name, DNSRecordAorAAAA);\n        var ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);\n        return SingleHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeCredential {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredential.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakecredential_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_keyhash(hash) {\n        _assertClass(hash, Ed25519KeyHash);\n        var ret = wasm.stakecredential_from_keyhash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_scripthash(hash) {\n        _assertClass(hash, ScriptHash);\n        var ret = wasm.stakecredential_from_scripthash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_keyhash() {\n        var ret = wasm.stakecredential_to_keyhash(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    to_scripthash() {\n        var ret = wasm.stakecredential_to_scripthash(this.ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.stakecredential_kind(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredential_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredential}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredential_from_bytes(ptr0, len0);\n        return StakeCredential.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredentials_from_bytes(ptr0, len0);\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    static new() {\n        var ret = wasm.stakecredentials_new();\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.stakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {StakeCredential}\n    */\n    get(index) {\n        var ret = wasm.stakecredentials_get(this.ptr, index);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} elem\n    */\n    add(elem) {\n        _assertClass(elem, StakeCredential);\n        wasm.stakecredentials_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class StakeDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakedelegation_from_bytes(ptr0, len0);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakedelegation_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = wasm.stakedelegation_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @returns {StakeDelegation}\n    */\n    static new(stake_credential, pool_keyhash) {\n        _assertClass(stake_credential, StakeCredential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = wasm.stakedelegation_new(stake_credential.ptr, pool_keyhash.ptr);\n        return StakeDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeDeregistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDeregistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakederegistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDeregistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakederegistration_from_bytes(ptr0, len0);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakederegistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeDeregistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = wasm.stakederegistration_new(stake_credential.ptr);\n        return StakeDeregistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakeregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakeregistration_from_bytes(ptr0, len0);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakeregistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeRegistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = wasm.stakeregistration_new(stake_credential.ptr);\n        return StakeRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Strings {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Strings.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_strings_free(ptr);\n    }\n    /**\n    * @returns {Strings}\n    */\n    static new() {\n        var ret = wasm.strings_new();\n        return Strings.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.strings_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {string}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.strings_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} elem\n    */\n    add(elem) {\n        var ptr0 = passStringToWasm0(elem, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.strings_add(this.ptr, ptr0, len0);\n    }\n}\n/**\n*/\nexport class TimelockExpiry {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockExpiry.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockexpiry_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockExpiry}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockexpiry_from_bytes(ptr0, len0);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.timelockexpiry_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} slot\n    * @returns {TimelockExpiry}\n    */\n    static new(slot) {\n        var ret = wasm.timelockexpiry_new(slot);\n        return TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TimelockStart {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockStart.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockstart_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockStart}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockstart_from_bytes(ptr0, len0);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.timelockstart_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} slot\n    * @returns {TimelockStart}\n    */\n    static new(slot) {\n        var ret = wasm.timelockstart_new(slot);\n        return TimelockStart.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Transaction}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_bytes(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    body() {\n        var ret = wasm.transaction_body(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    witness_set() {\n        var ret = wasm.transaction_witness_set(this.ptr);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    auxiliary_data() {\n        var ret = wasm.transaction_auxiliary_data(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBody} body\n    * @param {TransactionWitnessSet} witness_set\n    * @param {AuxiliaryData | undefined} auxiliary_data\n    * @returns {Transaction}\n    */\n    static new(body, witness_set, auxiliary_data) {\n        _assertClass(body, TransactionBody);\n        _assertClass(witness_set, TransactionWitnessSet);\n        let ptr0 = 0;\n        if (!isLikeNone(auxiliary_data)) {\n            _assertClass(auxiliary_data, AuxiliaryData);\n            ptr0 = auxiliary_data.ptr;\n            auxiliary_data.ptr = 0;\n        }\n        var ret = wasm.transaction_new(body.ptr, witness_set.ptr, ptr0);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBodies {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBodies.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbodies_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBodies}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbodies_from_bytes(ptr0, len0);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    static new() {\n        var ret = wasm.transactionbodies_new();\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionbodies_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionBody}\n    */\n    get(index) {\n        var ret = wasm.transactionbodies_get(this.ptr, index);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBody} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionBody);\n        wasm.transactionbodies_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbody_from_bytes(ptr0, len0);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        var ret = wasm.transactionbody_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    outputs() {\n        var ret = wasm.transactionbody_outputs(this.ptr);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    fee() {\n        var ret = wasm.transactionbody_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    ttl() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_ttl(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbody_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @returns {Certificates | undefined}\n    */\n    certs() {\n        var ret = wasm.transactionbody_certs(this.ptr);\n        return ret === 0 ? undefined : Certificates.__wrap(ret);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbody_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @returns {Withdrawals | undefined}\n    */\n    withdrawals() {\n        var ret = wasm.transactionbody_withdrawals(this.ptr);\n        return ret === 0 ? undefined : Withdrawals.__wrap(ret);\n    }\n    /**\n    * @param {Update} update\n    */\n    set_update(update) {\n        _assertClass(update, Update);\n        wasm.transactionbody_set_update(this.ptr, update.ptr);\n    }\n    /**\n    * @returns {Update | undefined}\n    */\n    update() {\n        var ret = wasm.transactionbody_update(this.ptr);\n        return ret === 0 ? undefined : Update.__wrap(ret);\n    }\n    /**\n    * @param {AuxiliaryDataHash} auxiliary_data_hash\n    */\n    set_auxiliary_data_hash(auxiliary_data_hash) {\n        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);\n        wasm.transactionbody_set_auxiliary_data_hash(this.ptr, auxiliary_data_hash.ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataHash | undefined}\n    */\n    auxiliary_data_hash() {\n        var ret = wasm.transactionbody_auxiliary_data_hash(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbody_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    validity_start_interval() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_validity_start_interval(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Mint} mint\n    */\n    set_mint(mint) {\n        _assertClass(mint, Mint);\n        wasm.transactionbody_set_mint(this.ptr, mint.ptr);\n    }\n    /**\n    * @returns {Mint | undefined}\n    */\n    multiassets() {\n        var ret = wasm.transactionbody_multiassets(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * @param {ScriptDataHash} script_data_hash\n    */\n    set_script_data_hash(script_data_hash) {\n        _assertClass(script_data_hash, ScriptDataHash);\n        wasm.transactionbody_set_script_data_hash(this.ptr, script_data_hash.ptr);\n    }\n    /**\n    * @returns {ScriptDataHash | undefined}\n    */\n    script_data_hash() {\n        var ret = wasm.transactionbody_script_data_hash(this.ptr);\n        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TransactionInputs);\n        wasm.transactionbody_set_collateral(this.ptr, collateral.ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    collateral() {\n        var ret = wasm.transactionbody_collateral(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHashes} required_signers\n    */\n    set_required_signers(required_signers) {\n        _assertClass(required_signers, Ed25519KeyHashes);\n        wasm.transactionbody_set_required_signers(this.ptr, required_signers.ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    required_signers() {\n        var ret = wasm.transactionbody_required_signers(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @param {NetworkId} network_id\n    */\n    set_network_id(network_id) {\n        _assertClass(network_id, NetworkId);\n        wasm.transactionbody_set_network_id(this.ptr, network_id.ptr);\n    }\n    /**\n    * @returns {NetworkId | undefined}\n    */\n    network_id() {\n        var ret = wasm.transactionbody_network_id(this.ptr);\n        return ret === 0 ? undefined : NetworkId.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @param {number | undefined} ttl\n    * @returns {TransactionBody}\n    */\n    static new(inputs, outputs, fee, ttl) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        var ret = wasm.transactionbody_new(inputs.ptr, outputs.ptr, fee.ptr, !isLikeNone(ttl), isLikeNone(ttl) ? 0 : ttl);\n        return TransactionBody.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilder_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    * @returns {BigNum}\n    */\n    fee_for_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        var ret = wasm.transactionbuilder_fee_for_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} output\n    */\n    add_output(output) {\n        _assertClass(output, TransactionOutput);\n        wasm.transactionbuilder_add_output(this.ptr, output.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {TransactionOutput} output\n    * @returns {BigNum}\n    */\n    fee_for_output(output) {\n        _assertClass(output, TransactionOutput);\n        var ret = wasm.transactionbuilder_fee_for_output(this.ptr, output.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} fee\n    */\n    set_fee(fee) {\n        _assertClass(fee, BigNum);\n        wasm.transactionbuilder_set_fee(this.ptr, fee.ptr);\n    }\n    /**\n    * @param {number} ttl\n    */\n    set_ttl(ttl) {\n        wasm.transactionbuilder_set_ttl(this.ptr, ttl);\n    }\n    /**\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbuilder_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbuilder_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbuilder_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @param {AuxiliaryData} auxiliary_data\n    */\n    set_auxiliary_data(auxiliary_data) {\n        _assertClass(auxiliary_data, AuxiliaryData);\n        wasm.transactionbuilder_set_auxiliary_data(this.ptr, auxiliary_data.ptr);\n    }\n    /**\n    * @param {LinearFee} linear_fee\n    * @param {BigNum} minimum_utxo_val\n    * @param {BigNum} pool_deposit\n    * @param {BigNum} key_deposit\n    * @returns {TransactionBuilder}\n    */\n    static new(linear_fee, minimum_utxo_val, pool_deposit, key_deposit) {\n        _assertClass(linear_fee, LinearFee);\n        _assertClass(minimum_utxo_val, BigNum);\n        _assertClass(pool_deposit, BigNum);\n        _assertClass(key_deposit, BigNum);\n        var ret = wasm.transactionbuilder_new(linear_fee.ptr, minimum_utxo_val.ptr, pool_deposit.ptr, key_deposit.ptr);\n        return TransactionBuilder.__wrap(ret);\n    }\n    /**\n    * does not include refunds or withdrawals\n    * @returns {Value}\n    */\n    get_explicit_input() {\n        var ret = wasm.transactionbuilder_get_explicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * withdrawals and refunds\n    * @returns {Value}\n    */\n    get_implicit_input() {\n        var ret = wasm.transactionbuilder_get_implicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * does not include fee\n    * @returns {Value}\n    */\n    get_explicit_output() {\n        var ret = wasm.transactionbuilder_get_explicit_output(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    get_deposit() {\n        var ret = wasm.transactionbuilder_get_deposit(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_fee_if_set() {\n        var ret = wasm.transactionbuilder_get_fee_if_set(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * Warning: this function will mutate the /fee/ field\n    * @param {Address} address\n    * @returns {boolean}\n    */\n    add_change_if_needed(address) {\n        _assertClass(address, Address);\n        var ret = wasm.transactionbuilder_add_change_if_needed(this.ptr, address.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    build() {\n        var ret = wasm.transactionbuilder_build(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it\n    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)\n    * this is done to simplify the library code, but can be fixed later\n    * @returns {BigNum}\n    */\n    min_fee() {\n        var ret = wasm.transactionbuilder_min_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transactionhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {TransactionHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_bech32(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_bytes(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninput_from_bytes(ptr0, len0);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionHash}\n    */\n    transaction_id() {\n        var ret = wasm.transactioninput_transaction_id(this.ptr);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    index() {\n        var ret = wasm.transactioninput_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionHash} transaction_id\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    static new(transaction_id, index) {\n        _assertClass(transaction_id, TransactionHash);\n        var ret = wasm.transactioninput_new(transaction_id.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninputs_from_bytes(ptr0, len0);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    static new() {\n        var ret = wasm.transactioninputs_new();\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactioninputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    get(index) {\n        var ret = wasm.transactioninputs_get(this.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionInput);\n        wasm.transactioninputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionMetadatum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_from_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataMap} map\n    * @returns {TransactionMetadatum}\n    */\n    static new_map(map) {\n        _assertClass(map, MetadataMap);\n        var ret = wasm.transactionmetadatum_new_map(map.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataList} list\n    * @returns {TransactionMetadatum}\n    */\n    static new_list(list) {\n        _assertClass(list, MetadataList);\n        var ret = wasm.transactionmetadatum_new_list(list.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {TransactionMetadatum}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.transactionmetadatum_new_int(int.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_new_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {TransactionMetadatum}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_new_text(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.transactionmetadatum_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    as_map() {\n        var ret = wasm.transactionmetadatum_as_map(this.ptr);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    as_list() {\n        var ret = wasm.transactionmetadatum_as_list(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {Int}\n    */\n    as_int() {\n        var ret = wasm.transactionmetadatum_as_int(this.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class TransactionMetadatumLabels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatumLabels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatumlabels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatumlabels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatumlabels_from_bytes(ptr0, len0);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    static new() {\n        var ret = wasm.transactionmetadatumlabels_new();\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionmetadatumlabels_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BigNum}\n    */\n    get(index) {\n        var ret = wasm.transactionmetadatumlabels_get(this.ptr, index);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} elem\n    */\n    add(elem) {\n        _assertClass(elem, BigNum);\n        wasm.transactionmetadatumlabels_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutput_from_bytes(ptr0, len0);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.transactionoutput_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    amount() {\n        var ret = wasm.transactionoutput_amount(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {DataHash | undefined}\n    */\n    data_hash() {\n        var ret = wasm.transactionoutput_data_hash(this.ptr);\n        return ret === 0 ? undefined : DataHash.__wrap(ret);\n    }\n    /**\n    * @param {DataHash} data_hash\n    */\n    set_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        wasm.transactionoutput_set_data_hash(this.ptr, data_hash.ptr);\n    }\n    /**\n    * @param {Address} address\n    * @param {Value} amount\n    * @returns {TransactionOutput}\n    */\n    static new(address, amount) {\n        _assertClass(address, Address);\n        _assertClass(amount, Value);\n        var ret = wasm.transactionoutput_new(address.ptr, amount.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionOutputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutputs_from_bytes(ptr0, len0);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    static new() {\n        var ret = wasm.transactionoutputs_new();\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionoutputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionOutput}\n    */\n    get(index) {\n        var ret = wasm.transactionoutputs_get(this.ptr, index);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionOutput);\n        wasm.transactionoutputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionUnspentOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionUnspentOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionunspentoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionunspentoutput_from_bytes(ptr0, len0);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {TransactionOutput} output\n    * @returns {TransactionUnspentOutput}\n    */\n    static new(input, output) {\n        _assertClass(input, TransactionInput);\n        _assertClass(output, TransactionOutput);\n        var ret = wasm.transactionunspentoutput_new(input.ptr, output.ptr);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInput}\n    */\n    input() {\n        var ret = wasm.transactionunspentoutput_input(this.ptr);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    output() {\n        var ret = wasm.transactionunspentoutput_output(this.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionWitnessSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnessset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSet}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnessset_from_bytes(ptr0, len0);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitnesses} vkeys\n    */\n    set_vkeys(vkeys) {\n        _assertClass(vkeys, Vkeywitnesses);\n        wasm.transactionwitnessset_set_vkeys(this.ptr, vkeys.ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses | undefined}\n    */\n    vkeys() {\n        var ret = wasm.transactionwitnessset_vkeys(this.ptr);\n        return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.transactionwitnessset_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = wasm.transactionwitnessset_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitnesses} bootstraps\n    */\n    set_bootstraps(bootstraps) {\n        _assertClass(bootstraps, BootstrapWitnesses);\n        wasm.transactionwitnessset_set_bootstraps(this.ptr, bootstraps.ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses | undefined}\n    */\n    bootstraps() {\n        var ret = wasm.transactionwitnessset_bootstraps(this.ptr);\n        return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.transactionwitnessset_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = wasm.transactionwitnessset_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} plutus_data\n    */\n    set_plutus_data(plutus_data) {\n        _assertClass(plutus_data, PlutusList);\n        wasm.transactionwitnessset_set_plutus_data(this.ptr, plutus_data.ptr);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    plutus_data() {\n        var ret = wasm.transactionwitnessset_plutus_data(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Redeemers} redeemers\n    */\n    set_redeemers(redeemers) {\n        _assertClass(redeemers, Redeemers);\n        wasm.transactionwitnessset_set_redeemers(this.ptr, redeemers.ptr);\n    }\n    /**\n    * @returns {Redeemers | undefined}\n    */\n    redeemers() {\n        var ret = wasm.transactionwitnessset_redeemers(this.ptr);\n        return ret === 0 ? undefined : Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    static new() {\n        var ret = wasm.transactionwitnessset_new();\n        return TransactionWitnessSet.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionWitnessSets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnesssets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnesssets_from_bytes(ptr0, len0);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    static new() {\n        var ret = wasm.transactionwitnesssets_new();\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionwitnesssets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionWitnessSet}\n    */\n    get(index) {\n        var ret = wasm.transactionwitnesssets_get(this.ptr, index);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {TransactionWitnessSet} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionWitnessSet);\n        wasm.transactionwitnesssets_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class URL {\n\n    static __wrap(ptr) {\n        const obj = Object.create(URL.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_url_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {URL}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_from_bytes(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @param {string} url\n    * @returns {URL}\n    */\n    static new(url) {\n        var ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_new(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    url() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_url(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class UnitInterval {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnitInterval.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unitinterval_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {UnitInterval}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.unitinterval_from_bytes(ptr0, len0);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    numerator() {\n        var ret = wasm.unitinterval_numerator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    denominator() {\n        var ret = wasm.unitinterval_denominator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} numerator\n    * @param {BigNum} denominator\n    * @returns {UnitInterval}\n    */\n    static new(numerator, denominator) {\n        _assertClass(numerator, BigNum);\n        _assertClass(denominator, BigNum);\n        var ret = wasm.unitinterval_new(numerator.ptr, denominator.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Update {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Update.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_update_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Update}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.update_from_bytes(ptr0, len0);\n        return Update.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    proposed_protocol_parameter_updates() {\n        var ret = wasm.update_proposed_protocol_parameter_updates(this.ptr);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = wasm.update_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates\n    * @param {number} epoch\n    * @returns {Update}\n    */\n    static new(proposed_protocol_parameter_updates, epoch) {\n        _assertClass(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);\n        var ret = wasm.update_new(proposed_protocol_parameter_updates.ptr, epoch);\n        return Update.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_from_bytes(ptr0, len0);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    output() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_output(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} output\n    * @param {Uint8Array} proof\n    * @returns {VRFCert}\n    */\n    static new(output, proof) {\n        var ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_new(ptr0, len0, ptr1, len1);\n        return VRFCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFKeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFKeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfkeyhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfkeyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.vrfkeyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFKeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_bech32(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFKeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_bytes(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfvkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.vrfvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_bech32(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_bytes(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Value {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Value.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_value_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Value}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.value_from_bytes(ptr0, len0);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {Value}\n    */\n    static new(coin) {\n        _assertClass(coin, BigNum);\n        var ret = wasm.value_new(coin.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        var ret = wasm.value_coin(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    */\n    set_coin(coin) {\n        _assertClass(coin, BigNum);\n        wasm.value_set_coin(this.ptr, coin.ptr);\n    }\n    /**\n    * @returns {MultiAsset | undefined}\n    */\n    multiasset() {\n        var ret = wasm.value_multiasset(this.ptr);\n        return ret === 0 ? undefined : MultiAsset.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    */\n    set_multiasset(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        wasm.value_set_multiasset(this.ptr, multiasset.ptr);\n    }\n    /**\n    * @param {Value} rhs\n    * @returns {Value}\n    */\n    checked_add(rhs) {\n        _assertClass(rhs, Value);\n        var ret = wasm.value_checked_add(this.ptr, rhs.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    checked_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_checked_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    clamped_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_clamped_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * note: values are only partially comparable\n    * @param {Value} rhs_value\n    * @returns {number | undefined}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_compare(this.ptr, rhs_value.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nexport class Vkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkey_from_bytes(ptr0, len0);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} pk\n    * @returns {Vkey}\n    */\n    static new(pk) {\n        _assertClass(pk, PublicKey);\n        var ret = wasm.vkey_new(pk.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    public_key() {\n        var ret = wasm.vkey_public_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Vkeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeys_free(ptr);\n    }\n    /**\n    * @returns {Vkeys}\n    */\n    static new() {\n        var ret = wasm.vkeys_new();\n        return Vkeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.vkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkey}\n    */\n    get(index) {\n        var ret = wasm.vkeys_get(this.ptr, index);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkey);\n        wasm.vkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Vkeywitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkeywitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkeywitness_from_bytes(ptr0, len0);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @returns {Vkeywitness}\n    */\n    static new(vkey, signature) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ret = wasm.vkeywitness_new(vkey.ptr, signature.ptr);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = wasm.vkeywitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = wasm.vkeywitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Vkeywitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitnesses_free(ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses}\n    */\n    static new() {\n        var ret = wasm.vkeywitnesses_new();\n        return Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.vkeywitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkeywitness}\n    */\n    get(index) {\n        var ret = wasm.vkeywitnesses_get(this.ptr, index);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkeywitness);\n        wasm.vkeywitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Withdrawals {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Withdrawals.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_withdrawals_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Withdrawals}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.withdrawals_from_bytes(ptr0, len0);\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {Withdrawals}\n    */\n    static new() {\n        var ret = wasm.withdrawals_new();\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.withdrawals_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {RewardAddress} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, RewardAddress);\n        _assertClass(value, BigNum);\n        var ret = wasm.withdrawals_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, RewardAddress);\n        var ret = wasm.withdrawals_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    keys() {\n        var ret = wasm.withdrawals_keys(this.ptr);\n        return RewardAddresses.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_3a746f2619705add(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_f54d3a6dadb199ca(arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_jsval_eq(arg0, arg1) {\n    var ret = getObject(arg0) === getObject(arg1);\n    return ret;\n};\n\nexport function __wbg_self_ac379e780a0d8b94(arg0) {\n    var ret = getObject(arg0).self;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_require_6461b1e9a0d7c34a(arg0, arg1) {\n    var ret = require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_crypto_1e4302b85d4f64a2(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_getRandomValues_1b4ba144162a5c9e(arg0) {\n    var ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_1ef11e888e5228e9(arg0, arg1, arg2) {\n    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbg_randomFillSync_1b52c8482374c55b(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import * as wasm from \"./cardano_serialization_lib_bg.wasm\";\nexport * from \"./cardano_serialization_lib_bg.js\";"],"sourceRoot":""}